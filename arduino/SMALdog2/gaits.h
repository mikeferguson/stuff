/******************************************************************************
 * Gaits Auto-Generated by NUKE!
 *   http://arbotix.googlecode.com
 *****************************************************************************/

//#define STD_TRANSITION          65
#define STD_TRANSITION          98
#define MOVING    ((travelX > 0 || travelX < 0) || (travelY > 0 || travelY < 0) || (travelRotZ > 0.0 || travelRotZ < 0.0))

void DefaultGaitSetup(){
  if(travelX > 0){
    bodyPosY = -6;
  }else{
    bodyPosY = 0;
  }
}

/* Simple, fast, and rough gait. StepsInCycle == leg count * X.
    Legs will make a fast triangular stroke. */
ik_req_t DefaultGaitGen(int leg){
  if( MOVING ){ 
    if(step == gaitLegNo[leg]){
      // leg up, middle position
      gaits[leg].x = 0;
      gaits[leg].y = 0; 
      gaits[leg].z = -liftHeight;
      gaits[leg].r = 0; 
    }else if(((step == gaitLegNo[leg]+1) || (step == gaitLegNo[leg]-(stepsInCycle-1))) && (gaits[leg].z < 0)){
      // leg down position NOTE: dutyFactor = pushSteps/StepsInCycle
      gaits[leg].x = (travelX*pushSteps)/(2*stepsInCycle);
      gaits[leg].y = (travelY*pushSteps)/(2*stepsInCycle);
      gaits[leg].z = 0;
      gaits[leg].r = (travelRotZ*pushSteps)/(2*stepsInCycle);
    }else{
      // move body forward
      gaits[leg].x = gaits[leg].x - (travelX/pushSteps);
      gaits[leg].y = gaits[leg].y - (travelY/pushSteps);
      //gaits[leg].z = 0;
      gaits[leg].r = gaits[leg].r - (travelRotZ/pushSteps);
    }
  }else{ // stopped
    gaits[leg].z = 0;        
  }
  return gaits[leg];
}

/* Which leg is the cross leg? */
int cross(int leg){
  switch(leg){
    case RIGHT_FRONT: return LEFT_REAR;
    case RIGHT_REAR:  return LEFT_FRONT;
    case LEFT_FRONT:  return RIGHT_REAR;
    case LEFT_REAR:   return RIGHT_FRONT;
  }
}

/* Simple gait, with a set body shift. StepsInCycle == leg count * X + 2 (for shift).
    Legs will make a fast triangular stroke. */
void RippleShiftSetup(){
  int i;
  if( MOVING ) {
    if(step == 0){        // Right front going up
      //gaits[LEFT_REAR].z = -10;
      //gaits[LEFT_FRONT].z = 0;
    }else if(step == 1){  // 
    
    }else if(step == 2){  // Shift off left rear
      //gaits[LEFT_REAR].z = 0;
      bodyPosY = -10;
      bodyRotX = 0;
    }else if(step == 3){  // Left rear going up
      //gaits[RIGHT_FRONT].z = -10;
    }else if(step == 4){  // Shift off left front
      bodyRotX = 0.1;  
    }else if(step == 5){  // Left front going up
      //gaits[RIGHT_FRONT].z = 0;
      gaits[RIGHT_REAR].z = -5;
    }else if(step == 6){
   
    }else if(step == 7){  // Shift off right rear
      gaits[RIGHT_REAR].z = 0;
      bodyPosY = 10;
      bodyRotX = 0;
    }else if(step == 8){  // Right rear going up
      //gaits[LEFT_FRONT].z = -10;
    }else if(step == 9){  // Shift off right front
      bodyRotX = -0.1;      
    }
    // raise cross foot
    //for(i=0;i<LEG_COUNT;i++){
    //  if(step == gaitLegNo[i]){
    //    gaits[cross(i)].z = -10;
    //  }else if(step == gaitLegNo[i]+2){
    //    gaits[cross(i)].z = 0;
    //  }
    //}
    // shift body
    //if(step == 2){    // shift off left rear
    //  bodyPosY = -10;
    //  bodyRotX = 0;
    //}else if(step == 4){
    //  bodyRotX = 0.1;
    //}else if(step == 7){
    //  bodyPosY = 10;
    //  bodyRotX = 0;
    //}else if(step == 9){
    //  bodyRotX = -0.1; 
    //} 
    // select trantime
    if(step == 0 || step == 3 || step == 5 || step == 8){
      tranTime = 65;
    }else if(step == 1 || step == 4 || step == 6 || step == 9){
      tranTime = 131;
    }else{
      tranTime = 98; 
    }
  }  
}

/* A Dynamic Double-Support Gait, sans Dynamicness */
void DoubleSupportSetup(){
  tranTime = 65;
  if(step == 0 || step == 4){        // front leg moving
    //bodyPosX = 10;    
    tranTime = 65;
  }else if(step == 1 || step == 5){  // rear leg moving
    //bodyPosX = 10;
    tranTime = 65;
  }else{                             // body moving
    //bodyPosX = 0;
    tranTime = 98; 
  }
}
ik_req_t DoubleSupportGen(int leg){
  if( MOVING ){ 
    if(step == gaitLegNo[leg]){
      // leg up, front position (note, no duty factor, this is discontinuous) 
      gaits[leg].x = travelX/2;
      gaits[leg].y = travelY/2;
      gaits[leg].z = -liftHeight;
      gaits[leg].r = travelRotZ/2;
    }else if((step == gaitLegNo[leg]+1) && (gaits[leg].z < 0)){
      gaits[leg].z = 0;
    }else if(step == 3 || step == 7){
      // move body forward
      gaits[leg].x = gaits[leg].x - travelX/2;
      gaits[leg].y = gaits[leg].y - travelY/2;
      gaits[leg].r = gaits[leg].r - travelRotZ/2;
    }
  }else{ // stopped
    gaits[leg].z = 0;        
  }
  return gaits[leg];
}

/* A discontinuous ripple, StepsInCycle = leg count * 2 + 
    Legs will make a fast triangular stroke. */
void RippleDiscoSetup(){
  tranTime = 48; //49;
  if(step == 2 || step == 7){
    tranTime = 160;
    bodyPosY = 0;
  }else if(step == 3){ // shift off left rear
    bodyPosY = -12;
  }else if(step == 8){ // shift off right rear
    bodyPosY = 12;
  }
}
ik_req_t RippleDiscoGen(int leg){
  if( MOVING ){ 
    if(step == gaitLegNo[leg]){
      // leg up, middle position
      gaits[leg].x = 0;
      gaits[leg].y = 0; 
      gaits[leg].z = -liftHeight;
      gaits[leg].r = 0; 
    }else if((step == gaitLegNo[leg]+1) && (gaits[leg].z < 0)){
      // leg down position NOTE: dutyFactor = pushSteps/StepsInCycle
      gaits[leg].x = travelX/2;
      gaits[leg].y = travelY/2;
      gaits[leg].z = 0;
      gaits[leg].r = travelRotZ/2;
    }else if((step == 2) || (step == 7)){
      // move body forward
      gaits[leg].x = gaits[leg].x - (travelX/pushSteps);
      gaits[leg].y = gaits[leg].y - (travelY/pushSteps);
      //gaits[leg].z = 0;
      gaits[leg].r = gaits[leg].r - (travelRotZ/pushSteps);
    }
  }else{ // stopped
    gaits[leg].z = 0;        
  }
  return gaits[leg];
}

/* Set the Y position */
void setStance(int stance){
  gaits[RIGHT_FRONT].y = gaits[RIGHT_FRONT].y + (endpoints[RIGHT_FRONT].y -stance);
  endpoints[RIGHT_FRONT].y = stance;
  gaits[RIGHT_REAR].y = gaits[RIGHT_REAR].y + (endpoints[RIGHT_REAR].y -stance);
  endpoints[RIGHT_REAR].y = stance;
  gaits[LEFT_FRONT].y = gaits[LEFT_FRONT].y + (endpoints[LEFT_FRONT].y +stance);
  endpoints[LEFT_FRONT].y = -stance;
  gaits[LEFT_REAR].y = gaits[LEFT_REAR].y + (endpoints[LEFT_REAR].y +stance);
  endpoints[LEFT_REAR].y = -stance;
}

int curGait = -1;

/* Select which gait to run */
void gaitSelect(int GaitType){
  tranTime = STD_TRANSITION;
  // No reason to reset gait
  if(GaitType == curGait) return;
  // proceed with selection
  bodyPosX = 0;
  if(GaitType == RIPPLE_SHIFT){     // simple ripple with body shift, 10 steps
    gaitGen = &DefaultGaitGen;
    gaitSetup = &RippleShiftSetup;
    gaitLegNo[RIGHT_FRONT] = 0;
    gaitLegNo[LEFT_REAR] = 3;
    gaitLegNo[LEFT_FRONT] = 5;
    gaitLegNo[RIGHT_REAR] = 8;
    pushSteps = 8;	
    stepsInCycle = 10;  
    setStance(30);
  }else if(GaitType == RIPPLE){     // simple ripple, 8 steps
    gaitGen = &DefaultGaitGen;
    gaitSetup = &DefaultGaitSetup;
    gaitLegNo[RIGHT_FRONT] = 0;
    gaitLegNo[LEFT_REAR] = 2;
    gaitLegNo[LEFT_FRONT] = 4;
    gaitLegNo[RIGHT_REAR] = 6;
    pushSteps = 6;	
    stepsInCycle = 8;   
    setStance(30);
  }else if(GaitType == AMBLE){      // fast step, 2 feet at a time
    gaitGen = &DefaultGaitGen;
    gaitSetup = &DefaultGaitSetup;
    gaitLegNo[RIGHT_FRONT] = 0;
    gaitLegNo[LEFT_REAR] = 0;
    gaitLegNo[LEFT_FRONT] = 2;
    gaitLegNo[RIGHT_REAR] = 2;
    pushSteps = 2;	
    stepsInCycle = 4;
    tranTime = 98;  
    setStance(50);                  // Need a wider stance
  }else if(GaitType == DOUBLE_SUPPORT){    
    gaitGen = &DoubleSupportGen;
    gaitSetup = &DoubleSupportSetup;
    gaitLegNo[RIGHT_FRONT] = 0;
    gaitLegNo[LEFT_REAR] = 1;
    // push on 3
    gaitLegNo[LEFT_FRONT] = 4;
    gaitLegNo[RIGHT_REAR] = 5;
    // push on 7
    pushSteps = 2;	
    stepsInCycle = 8;
    setStance(40);                  // Need a wider stance
  }else if(GaitType == RIPPLE_DISCO){
    gaitGen = &RippleDiscoGen;
    gaitSetup = &RippleDiscoSetup;
    gaitLegNo[RIGHT_FRONT] = 0;
    // push on 2
    gaitLegNo[LEFT_REAR] = 3;
    gaitLegNo[LEFT_FRONT] = 5;
    // push on 7
    gaitLegNo[RIGHT_REAR] = 8;
    pushSteps = 2;	
    stepsInCycle = 10;   
    setStance(40);
  }
  step = 0;
  curGait = GaitType; 
}

ik_req_t (*gaitGen)(int leg) = &DefaultGaitGen;
void (*gaitSetup)() = &DefaultGaitSetup;

